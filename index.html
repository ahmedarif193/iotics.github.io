<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EOTICS // SYSTEM INTERFACE</title>
    <style>
        /* --- CSS Reset & Base Styles --- */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Courier New', Courier, monospace;
        }

        /* --- 3D Canvas Container --- */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* --- CRT Scanline & Vignette Effects --- */
        .crt-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            background: linear-gradient(
                rgba(18, 16, 16, 0) 50%, 
                rgba(0, 0, 0, 0.25) 50%
            ), linear-gradient(
                90deg, 
                rgba(255, 0, 0, 0.06), 
                rgba(0, 255, 0, 0.02), 
                rgba(0, 0, 255, 0.06)
            );
            background-size: 100% 2px, 3px 100%;
            box-shadow: inset 0 0 80px rgba(0,0,0,0.9);
        }

        /* --- Terminal Overlay --- */
        #terminal-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            color: #00ff41;
            text-align: left;
            background: rgba(0, 10, 0, 0.9);
            padding: 2.5rem;
            border: 1px solid #00ff41;
            box-shadow: 0 0 30px rgba(0, 255, 65, 0.3);
            border-radius: 4px;
            width: 80%;
            max-width: 750px;
            backdrop-filter: blur(5px);
            
            /* Hidden initially for the animation sequence */
            opacity: 0;
            visibility: hidden;
            transition: opacity 1.5s ease-in-out;
        }

        #terminal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .terminal-header {
            border-bottom: 1px solid #333;
            margin-bottom: 15px;
            padding-bottom: 5px;
            color: #666;
            font-size: 0.8rem;
            letter-spacing: 2px;
        }

        .prompt { color: #00bfff; }
        .highlight { color: #fff; font-weight: bold; }
        
        .cursor {
            display: inline-block;
            width: 10px;
            height: 1.2em;
            background-color: #00ff41;
            animation: blink 1s step-end infinite;
            vertical-align: bottom;
        }

        #typewriter-text {
            line-height: 1.6;
            min-height: 100px;
            white-space: pre-wrap; /* Preserve line breaks */
        }

        .input-line {
            margin-top: 20px;
            border-top: 1px solid #333;
            padding-top: 15px;
            display: flex;
            align-items: center;
        }

        #user-input {
            color: #fff;
            margin-left: 10px;
            font-weight: bold;
        }

        #response-area {
            margin-top: 15px;
            color: #00bfff;
            white-space: pre-wrap;
            line-height: 1.5;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }
    </style>
</head>
<body>

    <div class="crt-overlay"></div>
    <div id="canvas-container"></div>

    <div id="terminal-overlay">
        <div class="terminal-header">:: ROOT ACCESS :: EOTICS_SHELL ::</div>
        
        <div id="terminal-text">
            <div id="typewriter-text"></div>
            
            <div class="input-line">
                <span class="prompt">root@eotics:~$</span> 
                <span id="user-input"></span><span class="cursor"></span>
            </div>
            
            <div id="response-area"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // ==========================================
        // CONFIGURATION
        // ==========================================
        const CONFIG = {
            companyText: "WELCOME TO EOTICS.\n\nWe are specialists in the Linux environment.\n\nWe create Linux firmware for embedded devices, manage cloud infrastructure, and manage virtualization solutions.\n\n[ Contact: contact@eotics.com ]\n\nType 'whoami' for technical capabilities...",
            
            whoamiResponse: "> LOADING KERNEL MODULES...\n> EXPERTISE DETECTED:\n\n  * Bootloader to Linux (U-Boot/Grub)\n  * Build Systems (Yocto/Buildroot)\n  * Driver Development & Kernel Hacking\n  * Cloud Linux Infrastructure\n  * Virtualization (KVM/QEMU/Containers)\n\n> SYSTEM READY.",
            
            // --- UPDATED TIMINGS (Total 3.0s) ---
            warpTime: 1.0,    // 1 Second Acceleration
            decelTime: 2.0,   // 2 Seconds Deceleration
            
            // --- UPDATED SPEED ---
            // Reduced by 20% (80 * 0.8 = 64)
            maxSpeed: 64,     
            baseStarSpeed: 0.5,
            
            // Visuals
            globeOpacity: 0.3, 
            starSize: 3.5,
            starCount: 6000,
            
            // Camera Zoom Settings
            warpDistance: 1000, 
            endDistance: 180     
        };

        // ==========================================
        // 1. SCENE SETUP
        // ==========================================
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.001);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
        camera.position.z = CONFIG.warpDistance; 

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // ==========================================
        // 2. OBJECTS
        // ==========================================
        
        // --- A. THE GLOBE ---
        const networkGroup = new THREE.Group();
        networkGroup.visible = false; 
        scene.add(networkGroup);

        const geometry = new THREE.IcosahedronGeometry(100, 1);

        // Wireframe 
        const wireframeMat = new THREE.MeshBasicMaterial({ 
            color: 0x00bfff, 
            wireframe: true, 
            transparent: true, 
            opacity: 0.0 
        });
        const wireMesh = new THREE.Mesh(geometry, wireframeMat);
        networkGroup.add(wireMesh);

        // Particles
        function getCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.4, 'rgba(0,255,65,0.5)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(canvas);
        }

        const pGeo = new THREE.BufferGeometry();
        pGeo.setAttribute('position', geometry.getAttribute('position'));
        const pMat = new THREE.PointsMaterial({
            color: 0x00ff41,
            size: 4,
            map: getCircleTexture(),
            transparent: true,
            opacity: 0.0,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        const pMesh = new THREE.Points(pGeo, pMat);
        networkGroup.add(pMesh);

        // --- B. THE STARS ---
        const starGeo = new THREE.BufferGeometry();
        const starPos = new Float32Array(CONFIG.starCount * 3);
        
        for(let i=0; i<CONFIG.starCount * 3; i++) {
            // Spread deeper (-3000 to +1000)
            starPos[i] = (Math.random() - 0.5) * 4000; 
        }
        
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const starMat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: CONFIG.starSize,
            transparent: true,
            opacity: 0.8
        });
        const starSystem = new THREE.Points(starGeo, starMat);
        scene.add(starSystem);

        // ==========================================
        // 3. ANIMATION LOOP
        // ==========================================
        let startTime = Date.now();
        let appState = 'WARP'; 

        function animate() {
            requestAnimationFrame(animate);
            
            const now = Date.now();
            const elapsed = (now - startTime) / 1000; 

            let currentSpeed = CONFIG.baseStarSpeed;

            // --- PHASE 1: ACCELERATION (0s to 1.0s) ---
            if (elapsed < CONFIG.warpTime) {
                const progress = elapsed / CONFIG.warpTime;
                
                // Acceleration Curve (ends at 64)
                currentSpeed = 2 + (Math.pow(progress, 3) * (CONFIG.maxSpeed - 2)); 
                
                networkGroup.visible = false;
            } 
            
            // --- PHASE 2: DECELERATION (1.0s to 3.0s) ---
            else if (elapsed < (CONFIG.warpTime + CONFIG.decelTime)) {
                // Progress goes 0.0 -> 1.0
                const progress = (elapsed - CONFIG.warpTime) / CONFIG.decelTime; 
                
                // 1. SPEED: Drops linearly from 64
                currentSpeed = CONFIG.maxSpeed * (1 - progress);
                if(currentSpeed < CONFIG.baseStarSpeed) currentSpeed = CONFIG.baseStarSpeed;

                // 2. GLOBE: Reveal
                networkGroup.visible = true;
                
                // 3. CAMERA: Linear Zoom
                const zDist = CONFIG.warpDistance - (progress * (CONFIG.warpDistance - CONFIG.endDistance));
                camera.position.z = zDist;
                
                // 4. OPACITY: Exponential Curve
                const opacityCurve = Math.pow(progress, 2.5);
                
                wireframeMat.opacity = opacityCurve * CONFIG.globeOpacity; 
                pMat.opacity = opacityCurve * 0.9;
                
                // 5. ROTATION
                networkGroup.rotation.y += (1 - progress) * 0.1;
            } 
            
            // --- PHASE 3: ARRIVED (3.0s+) ---
            else {
                if(appState !== 'ARRIVED') {
                    appState = 'ARRIVED';
                    initTerminal(); 
                }
                
                currentSpeed = CONFIG.baseStarSpeed;
                camera.position.z = CONFIG.endDistance;
                
                // Idle Rotation
                networkGroup.rotation.y += 0.003; 
                networkGroup.rotation.x += 0.002; 
                networkGroup.rotation.z -= 0.001;
                
                const pulse = 1 + Math.sin(now * 0.0015) * 0.03;
                networkGroup.scale.set(pulse, pulse, pulse);
            }

            // Move Stars
            const positions = starSystem.geometry.attributes.position.array;
            for(let i = 2; i < positions.length; i += 3) {
                positions[i] += currentSpeed;
                
                if(positions[i] > 1000) { 
                    positions[i] = -3000; 
                    positions[i-2] = (Math.random() - 0.5) * 4000;
                    positions[i-1] = (Math.random() - 0.5) * 4000;
                }
            }
            starSystem.geometry.attributes.position.needsUpdate = true;
            starSystem.rotation.z += 0.0005;

            renderer.render(scene, camera);
        }

        animate();

        // ==========================================
        // 4. TERMINAL LOGIC
        // ==========================================
        const termOverlay = document.getElementById('terminal-overlay');
        const typeEl = document.getElementById('typewriter-text');
        const inputEl = document.getElementById('user-input');
        const respEl = document.getElementById('response-area');
        
        let typeIndex = 0;
        let userInput = "";

        function initTerminal() {
            termOverlay.classList.add('visible');
            setTimeout(typeWriter, 1000);
        }

        function typeWriter() {
            if (typeIndex < CONFIG.companyText.length) {
                typeEl.textContent += CONFIG.companyText.charAt(typeIndex);
                typeIndex++;
                setTimeout(typeWriter, 25); 
            } else {
                enableInput();
            }
        }

        function enableInput() {
            document.addEventListener('keydown', (e) => {
                if (e.key === "Backspace") {
                    userInput = userInput.slice(0, -1);
                } else if (e.key.length === 1 && /[a-zA-Z0-9 @.]/.test(e.key)) {
                    userInput += e.key;
                }
                
                inputEl.textContent = userInput;

                if (userInput.toLowerCase().endsWith("whoami")) {
                     setTimeout(() => {
                         respEl.textContent = CONFIG.whoamiResponse;
                         userInput = ""; 
                         inputEl.textContent = "whoami"; 
                     }, 200);
                }
            });
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
